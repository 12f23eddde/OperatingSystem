# Executing Environment and Mechanism

```txt
Application <----> OS <----> Hardware
              |          |
     * System calls      |
                    * CPU state
                    * Interrupt / Exception Mechanism
```

## Terminology

Exceptional Control Flow (ECF) 異常控制流

* [Quizlet - Exceptional Control Flow](https://quizlet.com/15774161/exceptional-control-flow-flash-cards/)

Interrupt Descriptor Table (IDT) 中斷描述符表

* [Wiki - Interrupt descriptor table](https://en.wikipedia.org/wiki/Interrupt_descriptor_table)

> IDTR Interrupt Descriptor Table Register

[![stackoverflow IDTR w/ IDT](https://i.stack.imgur.com/Cld0q.png)](https://stackoverflow.com/questions/14551424/figuring-out-physical-address-by-hand-the-idtr-register)

## OS vs. Hardware

1. CPU
   * Register
2. Interrupt

### 1. CPU

#### Register

* User visible register
  * data register
  * address register
  * condition code register
* Control and State register (Only accessible with authority)
  * PC Program Counter
  * IR Instruction Register
  * PSW Program Status Word
    * [wiki](https://en.wikipedia.org/wiki/Program_status_word)
    * [PSW](http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm)

#### Protection

Hardware support:

* Executing different instruction set on different authority level.
* Seperate OS and user program.

#### Mode

Use PSW

Eflags register in x86

#### Privileged Instructions

> Privileged Instructions: Can only be used by OS. (can't be used by user)

* Kernel Mode
* User Mode

*Trap instruction* is non-privileged instruction (訪管指令)

* [Wiki - Trap (computing)](https://en.wikipedia.org/wiki/Trap_(computing))

> Example of X86: 4 different privilege
>
> * R0: kernel state
> * R1
> * R2
> * R3: user state
>
> In most of the x86 processor only use R0 and R3 privilege

#### CPU Mode Transform

* User Mode -> Kernel Mode
  * Only way: Interrupt/Exception/Trap Mechanism 中斷/異常/陷入機制
* Kernel Mode -> User Mode
  * Setting PSW to user mode

e.g. int, trap, syscall, sysenter/sysexit => 訪管指令 （不同系統implement的名稱可能不同）

### 2. Interrupt/Exception Mechanism

> OS is *interrupt triggered* or *event triggered*

* [Wiki - Interrupt](https://en.wikipedia.org/wiki/Interrupt)
* [Wiki - Exception handling](https://en.wikipedia.org/wiki/Exception_handling)

* Origin
  * Interrupt: Support parallel operation between CPU and device
  * Exception: Problem appear while CPU executing instruction

#### Event

* (External) Interrupt
  * I/O interrupt
  * Time interrupt
  * Hardware failure
* Exception (Internal Interrupt)
  * **System call**
  * **Page fault** 頁錯誤/故障
    * 缺頁異常
  * Protectional exception
  * Break point instruction
  * Other programming exception
    * e.g. overflow

-|Unexpected|Deliberate
---------------------|-----|------------
**Exceptions (sync)**|fault|syscall trap
**Interrupt (async)**|interrupt|software interrupt

> * Interrupts: asynchronous interrupts generated by hardware.
> * Exceptions: synchronous interrupts generated by the processor.

Class|Reason|Async/Sync|Return behavior
-----|------|-_--------|---------------
Interrupt|I/O device, peripheral|Async|Always return to next instruction
Trap|Arrange intentionally|Sync|Return to next instruction
Fault|Recoverable error|Sync|Return to current instruction
Abort|Unrecoverable error|Sync|Don't return

#### Interrupt Response

> Discover interrupt -> Receiving interrupt

#### Interrupt Vector Table (IVT)

* [Wiki - Interrupt vector table](https://en.wikipedia.org/wiki/Interrupt_vector_table)

#### Interrupt handler 中斷處理程序

* [Wiki - Interrupt handler](https://en.wikipedia.org/wiki/Interrupt_handler)

Procedure

1. Preserve relative registers
   * PC
   * PSW
2. Analysis the reason of Interrupt / Exception
3. Execute the corresponding funciton
4. Resume and return to the original program

Example of I/O Interrupt:

* I/O operation end normally
  * Wake up the process which is waiting for the result
* I/O operation fail
  * Retry the fail operation
  * Reach the tolerance maximum, determine as hardware failure

Implementation of Timer Interrupt:

* System necessary
* Software clock
* CPU scheduling
  * Round Robin
* Timing task
* Real-time execution

...

#### Interrupt in IA32

> IA32 = Intel's 32-Bit computer architecture = x86 (comes from the Intel Processor model number "Intel 8086") ([explained](http://lyberty.com/tech/terms/x86_WHAT-IS_.html))

* Interrupt
* Exception 異常
* System Call

IA32 system structure

![IA32 system structure](https://images0.cnblogs.com/blog/706575/201501/031410301699609.png)

* Advanced Programmable Interrupt Controller (APIC / PIC)
  * Transfer the *hardware interrupt signal* to *interrupt vector*, trigger CPU interrupt
* Interrupt Vector Table (Real Mode)
  * Store the *address of **interrupt handler***
* Interrupt Descriptor Table (Protection Mode)
  * Use data structure *gate descripter* to describe interrupt vector

Gates in Interupt Descriptor Table

* Task Gate
* Interrupt Gate
* Trap Gate
* Call Gate

![stackoverflow IDT Gate Descriptors](https://i.stack.imgur.com/ItKOI.png)

Procedure of Interrupt in x86

1. Get the *interrupt vector* (i)
2. Use IDTR find IDT then get *interrupt descriptor* (ith item in the table)
3. From GDTR get the address of GDT
4. Combine the *section selector* and get the corresponding section selector from GDT
5. From that *section selector* get the *base address* of *interrupt handler*
6. Check the privilege, make sure it's allow to access the segment
   * Make sure CPL (in CS Register) ≤ Gate descriptor DPL
     * Prevent user application access special trap gate or interrupt gate
   * Make sure RPL (in CS Register) ≤ Section descriptor DPL
     * Make sure current privilege greater than the privilege of interrupt handler

> * CPL Current privilege level
> * RPL Requested privilege level (privilege level associated with a segment selector)
> * DPL Descriptor privilege level (privilege level of a segment)
>   * It defines the minimum1 privilege level required to access the segment.
>
> Privilege levels range from 0-3; lower numbers are more privileged.

## Storage System

### Storage Hierarchy

> Register <--> Cache <--> Memory <--> Disk

### Memory Block

* Byte, Bit
* Page Frame (物理頁、頁框、頁幀)
  * Block / Page size
    * 512B, 1KB, 4KB, ..., 256KB, 1MB, 4MB, 16MB

### Cache

Cache (SRAM) 快取記憶體、高速緩存

```txt
┌-----┐                                ┌-------┐                          ┌--------┐
| CPU | <---Byte or Word transfer ---> | Cache | <--- Block transfer ---> | Memory |
└-----┘                                └-------┘                          └--------┘
```

### I/O Access

* Program Control
* Interrupt Trigger
* Direct Memory Access (DMA)

#### Program-based I/O

#### Interrupt-based I/O

#### DMA-based I/O

* [Wiki - Direct memory access](https://en.wikipedia.org/wiki/Direct_memory_access)

### Timer

> TCON (Timer Control register)

## System Call

Library
API

Kernel Function

Example: printf

printf() --> write() (syscall)

### System Call Design

* Interrupt/Exception Mechanism
* Trap Instruction/Privilege Instruction
* System call number and parameter
* System call table

> In Linux, each system call is assigned a unique syscall number that is used to reference a specific system call.

#### Passing Parameter

> Passing parameter from user program to kernel

* Trap instruction with argument
  * limited paramter number
* General purpose register
  * can be accessed by both user and system
  * limited register number
    * it's completely fine in 64bit system
* Special purpose stack heap area in memory

> `return` is also a syscall (No. 1)

Ctrl + C

Soft interrupt

send a signal --> .... -> ....

### System Call Procedure

When CPU execute special trap instruction

1. Interrup/Exception mechanism: **Protect** state by hardware
2. Invoke `sysenter`: **Preserve** state
3. Execute *system call handler*
4. **Resume** state

### System Call in Linux (based on x86)

> [include/linux/syscalls.h](https://github.com/torvalds/linux/blob/master/include/linux/syscalls.h)

System call number

> [arch/sh/include/uapi/asm/unistd_64.h](https://github.com/torvalds/linux/blob/master/arch/sh/include/uapi/asm/unistd_64.h)

```c
#define __NR_restart_syscall	  0
#define __NR_exit		  1
#define __NR_fork		  2
#define __NR_read		  3
#define __NR_write		  4
#define __NR_open		  5
#define __NR_close		  6
#define __NR_waitpid		  7
#define __NR_creat		  8
#define __NR_link		  9
#define __NR_unlink		 10
#define __NR_execve		 11
#define __NR_chdir		 12
#define __NR_time		 13
...
```

In Linux, all the system call use the same single entrance `int`: 0x80

```c
#define __NR_init_module	128
```

* Change privilege => change stack
  * User stack => Kernel stack

Examples....

#### OS low-level procedure after interrupt

1. (Hardware) Push stack
   * PC, etc.
2. (Hardware) Insert new PC from interrupt vector
3. (Assembly) Preserve value of registers
4. (Assembly) Set new stack and heap
5. (C language) Execute interrupt handler
6. (CPU Scheduler) Decide next process
7. (C language) Return to Assembly
8. (Assembly) Start running new process

### Mechanism and Seperation Principle

## Resources

* [CPL vs. DPL vs. RPL](https://stackoverflow.com/questions/36617718/difference-between-dpl-and-rpl-in-x86)
* [What is x86, IA32, IA64?](http://lyberty.com/tech/terms/x86_WHAT-IS_.html)
* [Stackoverflow - kernel stack and user space stack](https://stackoverflow.com/questions/12911841/kernel-stack-and-user-space-stack)
* [Chapter 8 Exceptional Control Flow](http://csapp.cs.cmu.edu/2e/ch8-preview.pdf)

### Article

* [Shichao's Notes Chapter 5. System Calls](https://notes.shichao.io/lkd/ch5/)
* [Shichao's Notes Chapter 7. Interrupts and Interrupt Handlers](https://notes.shichao.io/lkd/ch7/)
