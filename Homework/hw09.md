##### 1. 总结“文件缓冲”技术（150字）

磁盘的I/O性能，尤其是随机访问性能，远远弱于内存，这是众所皆知的。提升I/O性能一个非常自然的想法就是加入缓存，这就构成了”文件缓冲”机制。由于程序的访存行为存在时间的局部性（这正是缓存机制实现的基础），一个被访问过的块很可能会在将来的一段时间内被再次访问，因此我们在内存中分配一个缓冲区，用于磁盘高速缓存。当读磁盘时，内核将磁盘块放入缓冲区，下一次读同一个块就可以直接从内存中取数据；当写磁盘时（这里以Windows的Write Back为例），内核会将修改后的磁盘块放入缓冲区，在合适的时候（比如该块被置换出缓存）再写回磁盘。这样的做法尽可能减少了写回磁盘的数据量，并且可以通过合理的置换机制，将一批数据块一次性写入磁盘，通过提高I/O性能。

考虑到访存的空间局部性原理，我们也可以在读磁盘时多读入一些磁盘块，毕竟读入连续的磁盘块时间开销很小，重新寻道的时间开销很大。

##### 2. 总结虚拟文件系统（300字）

顾名思义，虚拟文件系统是虚拟的文件系统，是多个不同文件系统的抽象。

###### 虚拟文件系统的功能如下：

1. 在不同文件系统上实现统一的文件和文件系统接口
2. 提供管理所有文件和文件系统关联的数据结构
3. 在文件系统内进行高效查询
4. 与特定文件系统模块的交互

###### 我们以Linux VFS为例，说明虚拟文件系统的意义：

Linux内核支持EXT，FAT，brtfs等许多种文件系统。然而我们显然不希望每引入一种文件系统的支持，就需要大量修改内核的系统调用实现；我们也不希望程序为了利用缓存、日志等机制获取高I/O性能，而被迫关注具体文件系统的实现机制，从而给程序开发带来很多不必要的麻烦。因此，Linux引入了VFS抽象层，read()、write()等I/O操作均会交由VFS中间层处理，并不会直接操作磁盘。之前我们提到过虚拟文件系统是多个不同文件系统的抽象，而VFS在抽象的过程中取了所有文件系统特性的并集，也就是VFS封装了几乎所有应用程序可能会用到的文件系统特性，并集成了如inode cache、文件预读取等功能，使开发者不用过于关心内核实现的细节，就可以在目标文件系统上取得高I/O性能。

##### 3. 总结RAID技术（200字）

在SSD没有出现之前，机械硬盘的性能在很长的时间内没有明显的提升。一台存储服务器上可能包含几十甚至数百个磁盘，我们显然不希望整台存储服务器的性能与数据安全性与一块硬盘相当，因此出现了独立磁盘冗余阵列（RAID）机制。RAID使用了“条带化存储”的方法，数据会被分为多个条带（或块），当我们访问数据时可以并行地读写多个条带，从而提升了传输速率。（从这里我们自然可以猜想到，RAID对持续连续I/O性能的提升远远大于突发随机I/O）与此同时，我们可以利用条带机制对数据进行镜像和校验，从而提供冗余机制。即使阵列中出现少量的磁盘故障，我们也可以恢复完整的数据。

当我们设计RAID时，需要根据应用场景在速度、容量、容错、数据恢复性能之间取得平衡。以下介绍一些常见的RAID技术：

**RAID 0** 无冗余，无校验，数据同时分布在所有磁盘上。性能与存储空间利用率最高，数据安全性最低。

**RAID 1** 一个磁盘作为另一个磁盘的镜像。性能可能甚至低于单个磁盘，存储空间仅能利用50%，不过数据安全性最高，出现故障时能快速恢复。

**RAID 5** 为磁盘提供奇偶校验。在性能与安全性之间取得了平衡，性能高于单个磁盘，牺牲了一块磁盘的空间，从而允许阵列中一块磁盘损毁。

##### 参考资料

[Linux虚拟文件系统–VFS简介](https://www.linuxprobe.com/linux-vfs.html)

[几种RAID介绍（总结）](https://blog.csdn.net/weixin_43295278/article/details/88551933?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160838826316780304672460%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160838826316780304672460&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-88551933.nonecase&utm_term=RAID)