**1. 了解Linux的中断处理流程，解释为什么引入上半部和下半部处理？**

**上半部：**	

​	Linux中断处理的“上半部”类似与课件上讲的较为简单的中断处理方式。操作系统在运行用户态程序时发生中断后，大致分以下几个步骤进行处理：

（1）保存上下文 （2） 进入内核态运行中断服务程序 （3）恢复上下文 （4）进入用户态继续执行程序

​	中断服务程序会打断当前的控制流优先进行处理，且可以通过关中断防止中断服务程序被打断，因此以这种方式执行的中断服务程序的实时性能得到保证。然而，现代硬件种类繁多，系统调用日益复杂，长时间执行中断服务程序而不恢复控制流会对系统的调度效率造成不小的负面影响。

​	然而，有些时候操作系统需要处理例如硬件初始化之类的中断，这类中断对实时性要求很高。因此 ，满足

（1）执行用时短（2）对实时性要求高 (3) 不希望被打断

的中断服务程序依然在上半部执行。

**下半部：**

​	中断负责用户态程序与操作系统内核之间的通信，对于现代操作系统而言其重要性不言而喻；然而随着计算集群、网络应用的兴起，大量程序的并发、并行使得上半部简单的中断处理模式日渐捉襟见肘。现代高速SSD阵列的性能高达数百万IOPS，每秒响应数百万次的中断事件是仅凭上半部的处理方式极难实现的。

​	聪明的开发者们注意到，例如磁盘IO事件之类的中断事件完全不用实时执行，而且加深队列深度也可以提升系统的IO性能。于是出现了*软中断、Tasklet、任务队列*等实现方式，这构成了“下半部“；下半部的实现使内核能够对中断事件进行并行与调度。

**2. 以缺页异常为例，调研x86与ARM的中断异常机制，简述并比较两者的处理流程**

**x86：**

**ARM：**

**区别：**"思想相同，形式不同"