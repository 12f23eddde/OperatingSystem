### Multiprogramming ”多道程序设计“

我们先举一个打印店的例子：

​		有两位同学需要操作一台电脑使用一台打印机打印文件。对于一个没有多任务处理的系统来说，必须要等待上一位同学打印结束并且缴费完成后，下一位同学才能开始操作电脑，在打印机工作时电脑是完全闲置的。打印店老板发现了这一流程的低效，让下一位同学在上一位同学的文件正在打印时操作电脑，而下一位同学的文件开始打印后上一位同学再来缴费。这样的操作减少了等待时间，并同时提升了电脑和打印机的利用率。

​		以上例子简要地说明了Multiprogramming的原理。早期的大型计算机往往采用"单一程序设计"，即当一个程序执行完后下一个程序才开始执行。然而I/O设备工作往往需要大量的时间，在一个程序等待I/O设备处理完成时，CPU完全是空载的。小型机时代开始之后，多人共用一台计算机成为常见的使用场景，而一个人在使用打印机时其他人都无法进行任何操作，这造成大量的资源浪费（甚至会引发人际矛盾）。Multiprogramming的思想即是将所有程序的上下文加载到内存中，CPU则交替执行这些程序，因此其他程序可以在某一程序等待I/O设备处理完成时继续工作，借助“分时复用”提升资源的利用效率，并减少程序的响应时间。

<img src="/Users/Apple/Library/Application Support/typora-user-images/image-20201002143455248.png" alt="image-20201002143455248" style="zoom:20%;" />

<center>[图1] 现代计算机的图形界面离不开多任务处理</center>

### Three Easy Pieces

**virtualization "虚拟化"** 如何让程序更易于设计和使用？

**concurrency "并发"** 如何对同时执行的任务进行处理和调度？

**persistence "持久性"** 如何存储数据？

### 2.1 虚拟化CPU

​	在现代多核心CPU出现之前，很显然CPU只能在一个时候执行同一个程序。显然我们在编写程序的时候并不能考虑到运行时的所有情况，因此指望任务自己进行CPU调度很明显是不现实的。在同一时刻运行的所有程序都有自己独占整个CPU的错觉，而这一错觉是操作系统在有限的物理CPU上进行资源调度的结果，这一机制就被称为“虚拟化CPU”。

​	与此同时，为了控制程序的运行、停止，我们需要通过API与操作系统交互。事实上，这也是大多数时候用户与操作系统交互的方式。

​	当两个程序需要相同的资源，操作系统应该基于哪个程序优先运行的权力？为了解决这一问题，操作系统需要一系列的策略和机制来确保资源的调度合理且高效（资源管理器）。

### 2.2 虚拟化内存

​	在虚拟化内存出现之前，为多种计算机编写程序是一件极为痛苦的事。不同计算机有不同的物理内存大小和内存地址空间，因此程序必须针对每一种计算机的内存地址进行修改，而同时运行一个程序的两个相同实例也是不可能的。与CPU类似，现代操作系统中的程序也有自己独占整个内存地址空间的错觉；而事实上程序使用的是进程的私有内存地址空间，而操作系统负责进程的私有地址与物理内存地址的互相转换。这样一个进程使用的内存对其它进程来说是不可见的，简化编程的同时也提升了并发的内存安全性。操作系统进行内存地址转换的机制即为“虚拟化内存”。

