# Lab 4: Virtual Memory (and User Program)

> **Hints for this Lab**
>
> 1. Character sequencial order
>    * VMware virtual machine and normal PC is using [Little-Endian](https://en.wikipedia.org/wiki/Endianness#Little-endian)
>    * In Nachos simulator processor is using [Big-Endian](https://en.wikipedia.org/wiki/Endianness#Big-endian)
>    * Be careful when using `WordToMachine()` and `ShortToMachine()` for proper transition
> 2. How program is put in address space
>    * Nachos described this in `bin/noff.h`
>      * `Struct segment` represents a segmet of a program
>      * `Struct noffHeader` define the *code section*, *initialized data section* and *uninitialized data section*
> 3. Related source code
>    * `code/machine/machine.h`
>    * `code/machine/machine.cc`
>    * `code/machine/translate.h`
>    * `code/machine/translate.cc`
>    * `code/userprog/addrspace.h`
>    * `code/userprog/addrspace.cc`
>    * `code/userprog/exception.cc`

There is a micro called `HOST_IS_BIG_ENDIAN`. The `CheckEndian()` in `code/machine/machine.cc` will check the format by using a array.

The exception supported by Nachos is defined in `code/machine/machine.cc` and `code/machine/machine.h` Note that page fault and no TLB entry shared `PageFaultException` depends on using linear page table or TLB.

```cpp
// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };
```

```cpp
enum ExceptionType { NoException,           // Everything ok!
		     SyscallException,      // A program executed a system call.
		     PageFaultException,    // No valid translation found
		     ReadOnlyException,     // Write attempted to page marked 
					    // "read-only"
		     BusErrorException,     // Translation resulted in an 
					    // invalid physical address
		     AddressErrorException, // Unaligned reference or one that
					    // was beyond the end of the
					    // address space
		     OverflowException,     // Integer overflow in add or sub.
		     IllegalInstrException, // Unimplemented or reserved instr.
		     
		     NumExceptionTypes
};
```

The register is defined in `code/machine/machine.h`

> Nachos implement all the thirty-two MIPS R2/3000 Registers.
> Additionally, with 8 more special purpose register for better simulation and debug usage.

```cpp
// User program CPU state.  The full set of MIPS registers, plus a few
// more because we need to be able to start/stop a user program between
// any two instructions (thus we need to keep track of things like load
// delay slots, etc.)

// MIPS GPRs
#define StackReg	29	// User's stack pointer
#define RetAddrReg	31	// Holds return address for procedure calls

#define NumGPRegs	32	// 32 general purpose registers on MIPS

// Nachos SPRs
#define HiReg		32	// Double register to hold multiply result
#define LoReg		33
#define PCReg		34	// Current program counter
#define NextPCReg	35	// Next program counter (for branch delay) 
#define PrevPCReg	36	// Previous program counter (for debugging)
#define LoadReg		37	// The register target of a delayed load.
#define LoadValueReg 	38	// The value to be loaded by a delayed load.
#define BadVAddrReg	39	// The failing virtual address on an exception

#define NumTotalRegs 	40
```

[The MIPS registers](http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s03.html)

| Register Number | Conventional Name | Usage                                                  |
| --------------- | ----------------- | ------------------------------------------------------ |
| $0              | $zero             | Hard-wired to 0                                        |
| $1              | $at               | Reserved for pseudo-instructions                       |
| 2−3             | v0, v1            | Return values from functions                           |
| 4−7             | a0−a3             | Arguments to functions - not preserved by subprograms  |
| 8−15            | t0−t7             | Temporary data, not preserved by subprograms           |
| 16−23           | s0−s7             | Saved registers, preserved by subprograms              |
| 24−25           | t8−t9             | More temporary registers, not preserved by subprograms |
| 26−27           | k0−k1             | Reserved for kernel. Do not use.                       |
| $28             | $gp               | Global Area Pointer (base of global data segment)      |
| $29             | $sp               | Stack Pointer                                          |
| $30             | $fp               | Frame Pointer                                          |
| $31             | $ra               | Return Address                                         |

When define `USER_PROGRAM` (Compile `code/userprog`) the Machine will be create in `code/threads/system.h`

```cpp
#ifdef USER_PROGRAM
#include "machine.h"
extern Machine* machine;	// user program memory and registers
#endif
```

And in `code/threads/system.cc`

```cpp
void
Initialize(int argc, char **argv)
{
    // ...

#ifdef USER_PROGRAM
    bool debugUserProg = FALSE;	// single step user program
#endif

    // ...

#ifdef USER_PROGRAM
    if (!strcmp(*argv, "-s"))
        debugUserProg = TRUE;
#endif

    // ...

#ifdef USER_PROGRAM
    machine = new Machine(debugUserProg);	// this must come first
#endif
}
```

> Debug using `m` for machine emulation (including exception) and `a` for address spaces.
> Use `-s` to debug user program in single step. (this will show machine registers including PC and assembly instructions)

## I. TLB exception handling

> Currently, Nachos memory management is using software simulate the TLB mechanism.
> Its working principle, exception handling, replacement algorithm is similar with paging memory management.

### Exercise 1: Trace code

> Read the `code/userprog/progtest.cc`, understand the procedure of Nachos executing user program and memory menagement related point
>
> Read the following code, understand current Nachos TLB technique and Address Binding (地址轉換) mechanism
>
> * `code/machine/machine.h`
> * `code/machine/machine.cc`
> * `code/userprog/exception.cc`

#### Executing User Program

The `code/userprog/progtest.cc` is used to put all the test to simulate a user space program.

The entry point is in `code/threads/main.cc`. When using `-x` to execute Nachos, it will call `StartProcess()`, and it is defined in `code/userprog/progtest.cc`

In `StartProcess()` it will do three main step.

1. Open the executable file
   * using `FileSystem::Open()` which is defined in `code/filesys/filesys.cc`
2. Create a address space for the executable. Assign to current thread and then initial the register.

    ```cpp
    space = new AddrSpace(executable);
    currentThread->space = space;

    space->InitRegisters();		// set the initial register values
    space->RestoreState();		// load page table register
    ```

3. Finall call `Machine::Run()` to run the user program. And it's defined in `code/machine/mipssim.cc`

#### TLB Technique and Address Binding

In `code/machine/machine.cc` there is a macro called `USE_TLB` that controls whether to use TLB. (which should be enabled while compiling. I'll mention in [Exercise 2](#Exercise-2:-TLB-MISS-exception-handling))

The main memory is also defined in `code/machine/machine.cc` as `mainMemory` as an array of `char` with the size of `MemorySize`.

The initial TLB class `TranslationEntry` is declared in `code/machine/translate.h`. The TLB object has been used in `code/userprog/addrspace.h` as `*pageTable` and in `code/machine/machine.h` as `*tlb` (read-only pointer) and `*pageTable`. => Shared with Pate Table and TLB!

As mention, machine has a pointer to the "page table of the current user process" and a pointer to "system TLB".

The **memory translation** is defined in `code/machine/translate.cc` as `Machine::Translate()` (but is declared in `code/machine/machine.h`). The procedure is as following.

1. First get `vpn` and `offset`

    ```cpp
    vpn = (unsigned) virtAddr / PageSize;
    offset = (unsigned) virtAddr % PageSize;
    ```

2. There are two cases: use linear page table or use TLB (not both at the same time "in original implementation assumption")
   * If use page table

        ```cpp
        if (vpn >= pageTableSize) {
            DEBUG('a', "virtual page # %d too large for page table size %d!\n", virtAddr, pageTableSize);
            return AddressErrorException;
        } else if (!pageTable[vpn].valid) {
            DEBUG('a', "virtual page # %d too large for page table size %d!\n", virtAddr, pageTableSize);
            return PageFaultException;
        }

        entry = &pageTable[vpn];
        ```

   * If use TLB

        ```cpp
        for (entry = NULL, i = 0; i < TLBSize; i++)
            if (tlb[i].valid && (tlb[i].virtualPage == vpn)) {
            entry = &tlb[i];			// FOUND!
            break;
            }

        if (entry == NULL) {				// not found
                DEBUG('a', "*** no valid TLB entry found for this virtual page!\n");
                return PageFaultException;		// really, this is a TLB fault,
                            // the page may be in memory,
                            // but not in the TLB
        }
        ```

3. Read-only error detection
4. Get the page frame number

    ```cpp
    pageFrame = entry->physicalPage
    ```

5. Check if the page frame is valid
6. Combine to get the physical address!

    ```cpp
    *physAddr = pageFrame * PageSize + offset
    ```

The `Machine::Translate()` is called when using `Machine::ReadMem()` and `Machine::WriteMem()`. When the exception is raised it will called `Machine::RaiseException()`. In it will switch to System Mode and call the `ExceptionHandler()` in `code/userprog/exception.cc`. And then it will call `Machine::ReadRegister(2)` to get the type. But in initial state, this only handle the `SC_Halt` type `SyscallException`. (The system call types are defined in `code/userprog/syscall.h`)

#### Memory Related Definition

In `code/machine/machine.h`.

```cpp
// Definitions related to the size, and format of user memory

#define PageSize 	SectorSize 	// set the page size equal to
					// the disk sector size, for
					// simplicity

#define NumPhysPages    32
#define MemorySize 	(NumPhysPages * PageSize)
#define TLBSize		4		// if there is a TLB, make it small
```

In `code/machine/disk.h`.

```cpp
#define SectorSize 		128	// number of bytes per disk sector
```

So we can found that the total memory size `MemorySize` is **32 × 128 Bytes = 4KB**.

### Exercise 2: TLB MISS exception handling

> Modify the `ExceptionHandler()` in `code/userprog/exception.cc`. Makes Nachos able to handle TLB exception
>
> (When TLB exception, Nachos will throw **PageFaultException**. Reference `code/machine/machine.cc`)

To use TLB must define the `USE_TLB` macro that I've mentioned in Exercise 1.

So add `-DUSE_TLB` in `code/userprog/Makefile`

```makefile
DEFINES = -DUSE_TLB
```

> I was decided to change the original `ExceptionHandler()` in `code/userprog/exception.cc` to use switch case instead of if else.
> But I want to make as little modification as possible at this point.
> So maybe wait until implementing system call.

#### How Nachos Fetch Instruction

In `code/machine/mipssim.cc`

```c
Machine::Run() {
    ...

    while (1) {
        OneInstruction(instr);

        ...
    }
}
```

```c
Machine::OneInstruction(Instruction *instr)
{
    ...

    // Fetch instruction
    if (!machine->ReadMem(registers[PCReg], 4, &raw))
        return;			// exception occurred
    instr->value = raw;
    instr->Decode();

    ...

    // Compute next pc, but don't install in case there's an error or branch.
    int pcAfter = registers[NextPCReg] + 4;

    ...


    // Now we have successfully executed the instruction.

    ...

    // Advance program counters.
    registers[PrevPCReg] = registers[PCReg];	// for debugging, in case we
						// are jumping into lala-land
    registers[PCReg] = registers[NextPCReg];
    registers[NextPCReg] = pcAfter;
```

If Nachos fail fetch instruction (most likely to be Page Fault Exception). Then it won't execute PC+4 because `machine->ReadMem()` will return false.

Thus we only need to update TLB in exception handler, and Nachos will execute same instruction and try to translate again.

#### The BadVAddr Register in MIPS

This register (its name stands for **Bad V**irtual **Addr**ess) will contain the memory address where the exception
has occurred. An unaligned memory access, for instance, will generate an exception and the address where
the access was attempted will be stored in BadVAddr.

#### Page Fault

There are two cases will lead to page fault.

1. TLB miss
   * When doing either `Machine::ReadMem()` or `Machine::WriteMem()` in `code/machine/translate.cc` and TLB fail. It will pass `addr` and call `Machine::RaiseException()` in `code/machine/machine.cc`. And then it will preserve this address in `BadVAddrReg`

        ```cpp
        registers[BadVAddrReg] = badVAddr;
        ```

   * Thus all we need to do is to read the address from the `BadVAddrReg` and then calculate the `vpn` in `ExceptionHandler()` in `code/userprog/exception.cc`. And there are two cases
     1. There is empty entry in TLB. Insert it into TLB.
     2. TLB is full. Replace with some algorithm which will be implement in [Exercise 3](#Exercise-3:-Replacement-algorithm).
2. Page table failed
   * For now this won't happen because all the page frame are loaded in the memory.
     * When `new AddrSpace(executable)` in `code/userprog/progtest.cc` the `StartProcess()` function. While initializing a address space will check `ASSERT(numPages <= NumPhysPages)`. (Thus the total user program is [limited in 4KB](#Memory-Related-Definition)) => So page table won't fail at this point.
     * The problem will be mentioned again and will be solved in [Exercise 7](#Exercise-7:-Loading-page-on-demand) which will implement the demend paging technique.

Disable the `ASSERT(tlb == NULL || pageTable == NULL);` in `code/machine/translate.cc` to let TLB exist with the page table.

The way to seperate the exception caused by TLB or origianl linear page table is to check `if(machine->tlb == NULL)`. Just like the default Nachos did in the `Machine::Translate` in `code/machine/translate.cc`.

In `code/userprog/exception.cc` append the `ExceptionHandler()` as the following:

```cpp
void
ExceptionHandler(ExceptionType which)
{
    // Lab4: Page Fault Handling
    if (which == PageFaultException) {
        if (machine->tlb == NULL) { // linear page table page fault
            DEBUG('m', "=> Page table page fault.\n");
            // In current Nachos this shouldn't happen
            // because physical page frame == virtual page number
            // (can be found in AddrSpace::AddrSpace in userprog/addrspace.cc)
            // On the other hand, in our Lab we won't use linear page table at all
            ASSERT(FALSE);
        } else { // TLB miss (no TLB entry)
            // Lab4 Exercise2
            DEBUG('m', "=> TLB miss (no TLB entry)\n");
            int BadVAddr = machine->ReadRegister(BadVAddrReg); // The failing virtual address on an exception
            TLBMissHandler(BadVAddr);
        }
        return;
    }

    // System Call
    ...
}
```

#### Test Exercise 2

In this exercise, I test the TLB with only 2 entry to simplify the test.
There is a reason that we couldn't simplify test with TLB with only 1 entry. Because in `Machine::OneInstruction()` it will always need to fetch the instruction using `Machine::ReadMem()`.
But in some operation it will need to use `Machine::WriteMem()`. If we fail on the second `Machine::Translate()`, it will return False. And re-fetch the instruction again. And thus override the TLB miss handling that we've just made for the second one.
This will end up cause the infinity loop.

Here is the simplified `TLBMissHandler()`

```cpp
int TLBreplaceIdx = 0;

void
TLBMissHandler(int virtAddr)
{
    unsigned int vpn;
    vpn = (unsigned) virtAddr / PageSize;

    // ONLY USE FOR TESTING Lab4 Exercise2
    // i.e. assume TLBSize = 2
    machine->tlb[TLBreplaceIdx] = machine->pageTable[vpn];
    TLBreplaceIdx = TLBreplaceIdx ? 0 : 1;
}
```

> Test using the executable test program in `code/test`.
> (If the file is too big will get `Assertion failed: line 81, file "../userprog/addrspace.cc"`)
>
> Using docker (compiled with `cd Lab/Lab0_BuildNachos; ./build_subdir_nachos.sh userprog`)
>
> ```sh
> docker run nachos_userprog nachos/nachos-3.4/code/userprog/nachos -d am -x nachos/nachos-3.4/code/test/halt

Here is the result:

```txt
Initializing address space, num pages 10, size 1280
Initializing code segment, at 0x0, size 256
Initializing stack register to 1264
Starting thread "main" at time 10
Reading VA 0x0, size 4
        Translate 0x0, read: *** no valid TLB entry found for this virtual page!
Exception: page fault/no TLB entry
=> TLB miss (no TLB entry)
Reading VA 0x0, size 4
        Translate 0x0, read: phys addr = 0x0
        value read = 0c000034
At PC = 0x0: JAL 52
Reading VA 0x4, size 4
        Translate 0x4, read: phys addr = 0x4
        value read = 00000000
At PC = 0x4: SLL r0,r0,0
Reading VA 0xd0, size 4
        Translate 0xd0, read: *** no valid TLB entry found for this virtual page!
Exception: page fault/no TLB entry
=> TLB miss (no TLB entry)
Reading VA 0xd0, size 4
        Translate 0xd0, read: phys addr = 0xd0
        value read = 27bdffe8
At PC = 0xd0: ADDIU r29,r29,-24
Reading VA 0xd4, size 4
        Translate 0xd4, read: phys addr = 0xd4
        value read = afbf0014
At PC = 0xd4: SW r31,20(r29)
Writing VA 0x4ec, size 4, value 0x8
        Translate 0x4ec, write: *** no valid TLB entry found for this virtual page!
Exception: page fault/no TLB entry
=> TLB miss (no TLB entry)
Reading VA 0xd4, size 4
        Translate 0xd4, read: phys addr = 0xd4
        value read = afbf0014
At PC = 0xd4: SW r31,20(r29)
Writing VA 0x4ec, size 4, value 0x8
        Translate 0x4ec, write: phys addr = 0x4ec
Reading VA 0xd8, size 4
        Translate 0xd8, read: phys addr = 0xd8
        value read = afbe0010
At PC = 0xd8: SW r30,16(r29)
Writing VA 0x4e8, size 4, value 0x0
        Translate 0x4e8, write: phys addr = 0x4e8
Reading VA 0xdc, size 4
        Translate 0xdc, read: phys addr = 0xdc
        value read = 0c000030
At PC = 0xdc: JAL 48
Reading VA 0xe0, size 4
        Translate 0xe0, read: phys addr = 0xe0
        value read = 03a0f021
At PC = 0xe0: ADDU r30,r29,r0
Reading VA 0xc0, size 4
        Translate 0xc0, read: phys addr = 0xc0
        value read = 03e00008
At PC = 0xc0: JR r0,r31
Reading VA 0xc4, size 4
        Translate 0xc4, read: phys addr = 0xc4
        value read = 00000000
At PC = 0xc4: SLL r0,r0,0
Reading VA 0xe4, size 4
        Translate 0xe4, read: phys addr = 0xe4
        value read = 0c000004
At PC = 0xe4: JAL 4
Reading VA 0xe8, size 4
        Translate 0xe8, read: phys addr = 0xe8
        value read = 00000000
At PC = 0xe8: SLL r0,r0,0
Reading VA 0x10, size 4
        Translate 0x10, read: *** no valid TLB entry found for this virtual page!
Exception: page fault/no TLB entry
=> TLB miss (no TLB entry)
Reading VA 0x10, size 4
        Translate 0x10, read: phys addr = 0x10
        value read = 24020000
At PC = 0x10: ADDIU r2,r0,0
Reading VA 0x14, size 4
        Translate 0x14, read: phys addr = 0x14
        value read = 0000000c
At PC = 0x14: SYSCALL
Exception: syscall
Shutdown, initiated by user program.
Machine halting!
```

And it shows that the TLB mechanism worked!

> If use original linear page table
>
> ```txt
> Initializing address space, num pages 10, size 1280
> Initializing code segment, at 0x0, size 256
> Initializing stack register to 1264
> Starting thread "main" at time 10
> Reading VA 0x0, size 4
>         Translate 0x0, read: phys addr = 0x0
>         value read = 0c000034
> At PC = 0x0: JAL 52
> Reading VA 0x4, size 4
>         Translate 0x4, read: phys addr = 0x4
>         value read = 00000000
> At PC = 0x4: SLL r0,r0,0
> Reading VA 0xd0, size 4
>         Translate 0xd0, read: phys addr = 0xd0
>         value read = 27bdffe8
> At PC = 0xd0: ADDIU r29,r29,-24
> Reading VA 0xd4, size 4
>         Translate 0xd4, read: phys addr = 0xd4
>         value read = afbf0014
> At PC = 0xd4: SW r31,20(r29)
> Writing VA 0x4ec, size 4, value 0x8
>         Translate 0x4ec, write: phys addr = 0x4ec
> Reading VA 0xd8, size 4
>         Translate 0xd8, read: phys addr = 0xd8
>         value read = afbe0010
> At PC = 0xd8: SW r30,16(r29)
> Writing VA 0x4e8, size 4, value 0x0
>         Translate 0x4e8, write: phys addr = 0x4e8
> Reading VA 0xdc, size 4
>         Translate 0xdc, read: phys addr = 0xdc
>         value read = 0c000030
> At PC = 0xdc: JAL 48
> Reading VA 0xe0, size 4
>         Translate 0xe0, read: phys addr = 0xe0
>         value read = 03a0f021
> At PC = 0xe0: ADDU r30,r29,r0
> Reading VA 0xc0, size 4
>         Translate 0xc0, read: phys addr = 0xc0
>         value read = 03e00008
> At PC = 0xc0: JR r0,r31
> Reading VA 0xc4, size 4
>         Translate 0xc4, read: phys addr = 0xc4
>         value read = 00000000
> At PC = 0xc4: SLL r0,r0,0
> Reading VA 0xe4, size 4
>         Translate 0xe4, read: phys addr = 0xe4
>         value read = 0c000004
> At PC = 0xe4: JAL 4
> Reading VA 0xe8, size 4
>         Translate 0xe8, read: phys addr = 0xe8
>         value read = 00000000
> At PC = 0xe8: SLL r0,r0,0
> Reading VA 0x10, size 4
>         Translate 0x10, read: phys addr = 0x10
>         value read = 24020000
> At PC = 0x10: ADDIU r2,r0,0
> Reading VA 0x14, size 4
>         Translate 0x14, read: phys addr = 0x14
>         value read = 0000000c
> At PC = 0x14: SYSCALL
> Exception: syscall
> Shutdown, initiated by user program.
> Machine halting!
> ```

### Exercise 3: Replacement algorithm

> Implement at least two replacement algorithm, compare the replacement times between two algorithm.

## II. Paging Memory Management

> In the current Nachos, The member variable `AddrSpace* space` used in `Class Thread` use `TranslationEntry* pageTable` to manage memory.
> When application program is starting up it will initialize it; When context switch, it will also do reserve and resume.
> (Such that `Class Machine::TranslationEntry* pageTable` will always pointing at the current running Thread's page table)

### Exercise 4: Global data structure for memory management

> Impelement a global data structure for memory allocation and recycle, and record the current memory usage status
>
> e.g. Free Linked List (空閒鏈表)
>
> [![Linked List](https://www.cs.nuim.ie/~dkelly/CS240-05/Day%208%20Slides_files/image010.gif)](http://www.cs.nuim.ie/~dkelly/CS240-05/Day%208%20Slides.htm)
>
> e.g. Bitmap(位圖)
>
> [![Bitmap](https://www.cs.nuim.ie/~dkelly/CS240-05/Day%208%20Slides_files/image009.gif)](http://www.cs.nuim.ie/~dkelly/CS240-05/Day%208%20Slides.htm)

### Exercise 5: Support multi-threads

> In the current Nachos, only single Thread can exist in memory. We need to break this restriction

### Exercise 6: Missing page interrupt handling

> Based on TLB mechanism exception handling and the replacement algorithm. Implement missing page interrupt handler and page replacement algorithm.
>
> (The TLB exception mechanism is loading the page in memory from memory to TLB. Thus, missing page handler is to load new page from disk to memory)

## III. Lazy-loading (i.e. Demand Paging)

### Exercise 7: Loading page on demand

> Nachos allocate memory must be completed once the user program is loaded into memory. Thus the user program size is strictly restrict to be lower than 4KB.
> Implement a lazy-loading algorithm that load the page from disk to memory if and only if the missing page exception occur.

## Challenges

### Challenge 1

> Add `SUSPENDED` state for Thread. And implement the switching between `SUSPENDED`, `READY` and `BLOCKED`

### Challenge 2

> The defect of Hierarchical Paging (multi-level page table) is the page table size is *in direct ratio to* virtual address space.
> To reduce the consumption on physical page table. Implement inverted page table on Nachos.

## Resources

### Book

* Nachos Study Book Part III Storage Management
  * Ch6 Memory Management
    * Ch6.1 From Programs To Address Space
    * Ch6.4 MIPS Simulator
    * Ch6.5 Nachos User Programs
    * Ch6.6 Address Space of User Process in Nachos
    * Ch6.7 Memory Management in Nachos
    * Ch6.8 From Thread to User Process
  * Ch7 Implementation of System Calls
    * Ch7.3 Exception and Trap
  * Ch8 Virtual Memory

### Example

* [**Baidu文庫 - nachos Lab4實習報告**](https://wenku.baidu.com/view/be56dfe2541810a6f524ccbff121dd36a32dc430.html)
* [Baidu文庫 - 北大操作系統高級課程-陳向群作業-虛擬內存管理實習報告](https://wenku.baidu.com/view/420a3f6b04a1b0717ed5dd79.html)
* [Sina博客 - Nachos3.4 Lab3 虛擬內存管理 實習報告 TLB異常處理](http://blog.sina.com.cn/s/blog_4ae8f77f01018n63.html)
* [Sina博客 - Nachos3.4 Lab3 虛擬內存管理 實習報告 分頁式內存管理](http://blog.sina.com.cn/s/blog_4ae8f77f01018n6r.html)

Other

* [Nachos Assignment #3: Caching: TLB's and Virtual Memory](http://home.iitk.ac.in/~kbakshay/cs330assignment1/nachos/doc/pdf/vm.pdf)
* [Nachos Assignment 2: TLB and Virtual Memory](http://www.cas.mcmaster.ca/~qiao/courses/cs3mh3/assignments/a072f.pdf)
* [Phase 3: Caching and Virtual Memory](https://people.eecs.berkeley.edu/~kubitron/courses/cs162-F05/Nachos/phase3.html)

Another

* [MrOrz/nachos/userprog/exception.cc](https://github.com/MrOrz/nachos/blob/master/userprog/exception.cc)
* [MrOrz/nachos/userprog/addrspace.cc](https://github.com/MrOrz/nachos/blob/master/userprog/addrspace.cc)

> seems didn't consider TLB

Yet Another

* [Cheejyg/CZ2005-Operating-Systems-Experiment-3-Virtual-Memory](https://github.com/Cheejyg/CZ2005-Operating-Systems-Experiment-3-Virtual-Memory)
